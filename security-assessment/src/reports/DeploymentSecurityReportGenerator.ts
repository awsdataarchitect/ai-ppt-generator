/**
 * Deployment Security Report Generator
 * 
 * Generates comprehensive markdown reports for deployment security assessment findings
 * including CI/CD pipeline security, environment configuration, and production deployment risks
 */

import { VulnerabilityFinding, VulnerabilitySeverity, VulnerabilityCategory } from '../types/VulnerabilityTypes';
import { DeploymentScanResult } from '../scanners/DeploymentSecurityScanner';

export interface DeploymentSecurityReport {
  executiveSummary: string;
  deploymentFindings: string;
  environmentFindings: string;
  buildSecurityFindings: string;
  monitoringFindings: string;
  networkSecurityFindings: string;
  backupSecurityFindings: string;
  remediationPlan: string;
  complianceAssessment: string;
  recommendations: string;
}

export class DeploymentSecurityReportGenerator {
  
  /**
   * Generate comprehensive deployment security report
   */
  public generateReport(scanResult: DeploymentScanResult): DeploymentSecurityReport {
    const findings = scanResult.findings;
    
    return {
      executiveSummary: this.generateExecutiveSummary(scanResult),
      deploymentFindings: this.generateDeploymentFindings(findings),
      environmentFindings: this.generateEnvironmentFindings(findings),
      buildSecurityFindings: this.generateBuildSecurityFindings(findings),
      monitoringFindings: this.generateMonitoringFindings(findings),
      networkSecurityFindings: this.generateNetworkSecurityFindings(findings),
      backupSecurityFindings: this.generateBackupSecurityFindings(findings),
      remediationPlan: this.generateRemediationPlan(findings),
      complianceAssessment: this.generateComplianceAssessment(findings),
      recommendations: this.generateRecommendations(findings)
    };
  }

  /**
   * Generate full markdown report
   */
  public generateMarkdownReport(scanResult: DeploymentScanResult): string {
    const report = this.generateReport(scanResult);
    const timestamp = new Date().toISOString();
    
    return `# Deployment Security Assessment Report

**Generated:** ${timestamp}
**Scanner:** Deployment Security Scanner v1.0.0
**Project:** AI PPT Generator

---

## Executive Summary

${report.executiveSummary}

---

## Deployment Script Security Findings

${report.deploymentFindings}

---

## Environment Configuration Security

${report.environmentFindings}

---

## Build Process Security

${report.buildSecurityFindings}

---

## Monitoring and Logging Security

${report.monitoringFindings}

---

## Network Security Configuration

${report.networkSecurityFindings}

---

## Backup and Recovery Security

${report.backupSecurityFindings}

---

## Remediation Plan

${report.remediationPlan}

---

## Compliance Assessment

${report.complianceAssessment}

---

## Security Recommendations

${report.recommendations}

---

## Appendix: Detailed Findings

${this.generateDetailedFindings(scanResult.findings)}

---

*This report was generated by the Deployment Security Scanner as part of a comprehensive security assessment. All findings should be reviewed and validated before implementation.*
`;
  }

  private generateExecutiveSummary(scanResult: DeploymentScanResult): string {
    const { summary, findings } = scanResult;
    const riskLevel = this.calculateOverallRiskLevel(findings);
    
    return `### Security Assessment Overview

The deployment security assessment analyzed **${summary.totalFiles}** configuration and deployment files across the AI PPT Generator project infrastructure. The scan identified **${findings.length}** security findings across deployment scripts, environment configurations, build processes, and infrastructure setup.

**Risk Level:** ${riskLevel}

**Key Statistics:**
- **Critical Issues:** ${summary.criticalFindings}
- **High Risk Issues:** ${summary.highFindings}  
- **Medium Risk Issues:** ${summary.mediumFindings}
- **Low Risk Issues:** ${summary.lowFindings}
- **Files with Vulnerabilities:** ${summary.vulnerableFiles} of ${summary.totalFiles}

**Primary Concerns:**
${this.generatePrimaryConcerns(findings)}

**Immediate Actions Required:**
${this.generateImmediateActions(findings)}`;
  }

  private generateDeploymentFindings(findings: VulnerabilityFinding[]): string {
    const deploymentFindings = findings.filter(f => 
      f.location.filePath.includes('deploy') || 
      f.location.filePath.includes('build') ||
      f.location.filePath.includes('amplify.yml') ||
      f.category === VulnerabilityCategory.HARDCODED_SECRETS
    );

    if (deploymentFindings.length === 0) {
      return `### ‚úÖ No Critical Deployment Script Issues Found

The deployment scripts appear to follow security best practices with no hardcoded secrets or dangerous operations detected.`;
    }

    let report = `### üö® Deployment Script Security Issues (${deploymentFindings.length} findings)\n\n`;
    
    const criticalFindings = deploymentFindings.filter(f => f.severity === VulnerabilitySeverity.CRITICAL);
    const highFindings = deploymentFindings.filter(f => f.severity === VulnerabilitySeverity.HIGH);
    
    if (criticalFindings.length > 0) {
      report += `#### Critical Issues (${criticalFindings.length})\n\n`;
      criticalFindings.forEach(finding => {
        report += this.formatFindingBrief(finding);
      });
    }

    if (highFindings.length > 0) {
      report += `#### High Risk Issues (${highFindings.length})\n\n`;
      highFindings.forEach(finding => {
        report += this.formatFindingBrief(finding);
      });
    }

    return report;
  }

  private generateEnvironmentFindings(findings: VulnerabilityFinding[]): string {
    const envFindings = findings.filter(f => 
      f.location.filePath.includes('.env') ||
      f.description.toLowerCase().includes('environment')
    );

    if (envFindings.length === 0) {
      return `### ‚úÖ Environment Configuration Security

Environment configurations appear to be properly secured with no exposed secrets or misconfigurations detected.`;
    }

    let report = `### ‚ö†Ô∏è Environment Configuration Issues (${envFindings.length} findings)\n\n`;
    
    envFindings.forEach(finding => {
      report += this.formatFindingBrief(finding);
    });

    return report;
  }

  private generateBuildSecurityFindings(findings: VulnerabilityFinding[]): string {
    const buildFindings = findings.filter(f => 
      f.location.filePath.includes('webpack') ||
      f.location.filePath.includes('package.json') ||
      f.description.toLowerCase().includes('build') ||
      f.description.toLowerCase().includes('dependency')
    );

    if (buildFindings.length === 0) {
      return `### ‚úÖ Build Process Security

Build configurations follow security best practices with proper dependency management and secure build settings.`;
    }

    let report = `### üîß Build Process Security Issues (${buildFindings.length} findings)\n\n`;
    
    buildFindings.forEach(finding => {
      report += this.formatFindingBrief(finding);
    });

    return report;
  }

  private generateMonitoringFindings(findings: VulnerabilityFinding[]): string {
    const monitoringFindings = findings.filter(f => 
      f.category === VulnerabilityCategory.LOGGING_FAILURE ||
      f.description.toLowerCase().includes('logging') ||
      f.description.toLowerCase().includes('monitoring') ||
      f.description.toLowerCase().includes('cloudwatch')
    );

    if (monitoringFindings.length === 0) {
      return `### ‚úÖ Monitoring and Logging Security

Monitoring and logging configurations are properly implemented for security event detection and incident response.`;
    }

    let report = `### üìä Monitoring and Logging Issues (${monitoringFindings.length} findings)\n\n`;
    
    monitoringFindings.forEach(finding => {
      report += this.formatFindingBrief(finding);
    });

    return report;
  }

  private generateNetworkSecurityFindings(findings: VulnerabilityFinding[]): string {
    const networkFindings = findings.filter(f => 
      f.description.toLowerCase().includes('vpc') ||
      f.description.toLowerCase().includes('security group') ||
      f.description.toLowerCase().includes('network') ||
      f.description.toLowerCase().includes('cors') ||
      f.description.toLowerCase().includes('api gateway')
    );

    if (networkFindings.length === 0) {
      return `### ‚úÖ Network Security Configuration

Network security configurations are properly implemented with appropriate access controls and segmentation.`;
    }

    let report = `### üåê Network Security Issues (${networkFindings.length} findings)\n\n`;
    
    networkFindings.forEach(finding => {
      report += this.formatFindingBrief(finding);
    });

    return report;
  }

  private generateBackupSecurityFindings(findings: VulnerabilityFinding[]): string {
    const backupFindings = findings.filter(f => 
      f.description.toLowerCase().includes('backup') ||
      f.description.toLowerCase().includes('recovery') ||
      f.description.toLowerCase().includes('versioning') ||
      f.description.toLowerCase().includes('retention')
    );

    if (backupFindings.length === 0) {
      return `### ‚úÖ Backup and Recovery Security

Backup and recovery configurations are properly implemented with appropriate data protection measures.`;
    }

    let report = `### üíæ Backup and Recovery Issues (${backupFindings.length} findings)\n\n`;
    
    backupFindings.forEach(finding => {
      report += this.formatFindingBrief(finding);
    });

    return report;
  }

  private generateRemediationPlan(findings: VulnerabilityFinding[]): string {
    const criticalFindings = findings.filter(f => f.severity === VulnerabilitySeverity.CRITICAL);
    const highFindings = findings.filter(f => f.severity === VulnerabilitySeverity.HIGH);
    const mediumFindings = findings.filter(f => f.severity === VulnerabilitySeverity.MEDIUM);

    let plan = `### Prioritized Remediation Plan\n\n`;

    if (criticalFindings.length > 0) {
      plan += `#### Phase 1: Critical Issues (Immediate - 24 hours)\n\n`;
      criticalFindings.forEach((finding, index) => {
        plan += `**${index + 1}. ${finding.title}**\n`;
        plan += `- **File:** \`${finding.location.filePath}\`\n`;
        plan += `- **Action:** ${finding.remediation.summary}\n`;
        plan += `- **Effort:** ${finding.remediation.estimatedEffort}\n\n`;
      });
    }

    if (highFindings.length > 0) {
      plan += `#### Phase 2: High Risk Issues (1 week)\n\n`;
      highFindings.forEach((finding, index) => {
        plan += `**${index + 1}. ${finding.title}**\n`;
        plan += `- **File:** \`${finding.location.filePath}\`\n`;
        plan += `- **Action:** ${finding.remediation.summary}\n`;
        plan += `- **Effort:** ${finding.remediation.estimatedEffort}\n\n`;
      });
    }

    if (mediumFindings.length > 0) {
      plan += `#### Phase 3: Medium Risk Issues (1 month)\n\n`;
      mediumFindings.forEach((finding, index) => {
        plan += `**${index + 1}. ${finding.title}**\n`;
        plan += `- **File:** \`${finding.location.filePath}\`\n`;
        plan += `- **Action:** ${finding.remediation.summary}\n`;
        plan += `- **Effort:** ${finding.remediation.estimatedEffort}\n\n`;
      });
    }

    return plan;
  }

  private generateComplianceAssessment(findings: VulnerabilityFinding[]): string {
    const owaspFindings = this.categorizeByOWASP(findings);
    const nistFindings = this.categorizeByNIST(findings);

    return `### OWASP Top 10 Compliance

${this.generateOWASPAssessment(owaspFindings)}

### NIST Cybersecurity Framework Alignment

${this.generateNISTAssessment(nistFindings)}

### AWS Well-Architected Security Pillar

${this.generateAWSWellArchitectedAssessment(findings)}`;
  }

  private generateRecommendations(findings: VulnerabilityFinding[]): string {
    return `### Immediate Security Improvements

1. **Secrets Management**
   - Implement AWS Secrets Manager for all sensitive credentials
   - Remove any hardcoded secrets from deployment scripts
   - Use environment variables with proper access controls

2. **CI/CD Pipeline Security**
   - Enable branch protection rules in version control
   - Implement security scanning in CI/CD pipeline
   - Use signed commits and verified builds

3. **Infrastructure Security**
   - Enable comprehensive logging for all AWS services
   - Implement network segmentation with VPCs
   - Configure proper backup and disaster recovery

4. **Monitoring and Alerting**
   - Set up security event monitoring with CloudWatch
   - Configure alerts for suspicious activities
   - Implement log aggregation and analysis

### Long-term Security Strategy

1. **Security Automation**
   - Implement infrastructure as code security scanning
   - Automate vulnerability assessments in CI/CD
   - Use policy as code for compliance enforcement

2. **Incident Response**
   - Develop incident response procedures
   - Create security playbooks for common scenarios
   - Implement automated incident detection and response

3. **Continuous Improvement**
   - Regular security assessments and penetration testing
   - Security training for development team
   - Implement security metrics and KPIs`;
  }

  private generatePrimaryConcerns(findings: VulnerabilityFinding[]): string {
    const concerns: string[] = [];
    
    const criticalCount = findings.filter(f => f.severity === VulnerabilitySeverity.CRITICAL).length;
    if (criticalCount > 0) {
      concerns.push(`${criticalCount} critical security issues requiring immediate attention`);
    }

    const secretsCount = findings.filter(f => f.category === VulnerabilityCategory.HARDCODED_SECRETS).length;
    if (secretsCount > 0) {
      concerns.push(`${secretsCount} hardcoded secrets detected in deployment configurations`);
    }

    const loggingCount = findings.filter(f => f.category === VulnerabilityCategory.LOGGING_FAILURE).length;
    if (loggingCount > 0) {
      concerns.push(`${loggingCount} monitoring and logging configuration gaps`);
    }

    if (concerns.length === 0) {
      return '- No major security concerns identified in deployment configurations';
    }

    return concerns.map(concern => `- ${concern}`).join('\n');
  }

  private generateImmediateActions(findings: VulnerabilityFinding[]): string {
    const criticalFindings = findings.filter(f => f.severity === VulnerabilitySeverity.CRITICAL);
    
    if (criticalFindings.length === 0) {
      return '- Review and address high and medium priority findings\n- Implement continuous security monitoring';
    }

    const actions = criticalFindings.slice(0, 3).map(finding => 
      `- ${finding.remediation.summary} (${finding.location.filePath})`
    );

    if (criticalFindings.length > 3) {
      actions.push(`- Address ${criticalFindings.length - 3} additional critical findings`);
    }

    return actions.join('\n');
  }

  private calculateOverallRiskLevel(findings: VulnerabilityFinding[]): string {
    const criticalCount = findings.filter(f => f.severity === VulnerabilitySeverity.CRITICAL).length;
    const highCount = findings.filter(f => f.severity === VulnerabilitySeverity.HIGH).length;
    
    if (criticalCount > 0) {
      return 'üî¥ **HIGH RISK** - Critical issues require immediate attention';
    } else if (highCount > 2) {
      return 'üü° **MEDIUM RISK** - Multiple high-priority issues identified';
    } else if (highCount > 0) {
      return 'üü° **MEDIUM RISK** - Some high-priority issues identified';
    } else {
      return 'üü¢ **LOW RISK** - No critical or high-priority issues identified';
    }
  }

  private formatFindingBrief(finding: VulnerabilityFinding): string {
    const severityIcon = this.getSeverityIcon(finding.severity);
    
    return `${severityIcon} **${finding.title}**
- **File:** \`${finding.location.filePath}\`${finding.location.lineNumber ? `:${finding.location.lineNumber}` : ''}
- **Issue:** ${finding.description}
- **Impact:** ${finding.impact}
- **Remediation:** ${finding.remediation.summary}
- **Timeline:** ${finding.remediation.timeline}

`;
  }

  private getSeverityIcon(severity: VulnerabilitySeverity): string {
    switch (severity) {
      case VulnerabilitySeverity.CRITICAL:
        return 'üö®';
      case VulnerabilitySeverity.HIGH:
        return '‚ö†Ô∏è';
      case VulnerabilitySeverity.MEDIUM:
        return 'üî∂';
      case VulnerabilitySeverity.LOW:
        return '‚ÑπÔ∏è';
      default:
        return '‚ùì';
    }
  }

  private categorizeByOWASP(findings: VulnerabilityFinding[]): Map<string, VulnerabilityFinding[]> {
    const owaspMap = new Map<string, VulnerabilityFinding[]>();
    
    findings.forEach(finding => {
      const owaspCategories = finding.references.filter(ref => ref.startsWith('A0'));
      if (owaspCategories.length > 0) {
        owaspCategories.forEach(category => {
          if (!owaspMap.has(category)) {
            owaspMap.set(category, []);
          }
          owaspMap.get(category)!.push(finding);
        });
      }
    });
    
    return owaspMap;
  }

  private categorizeByNIST(findings: VulnerabilityFinding[]): Map<string, VulnerabilityFinding[]> {
    const nistMap = new Map<string, VulnerabilityFinding[]>();
    
    // Map findings to NIST categories based on vulnerability type
    findings.forEach(finding => {
      let nistCategory = '';
      
      switch (finding.category) {
        case VulnerabilityCategory.HARDCODED_SECRETS:
        case VulnerabilityCategory.AUTHENTICATION_BYPASS:
          nistCategory = 'PR.AC (Identity Management and Access Control)';
          break;
        case VulnerabilityCategory.LOGGING_FAILURE:
          nistCategory = 'DE.AE (Anomalies and Events)';
          break;
        case VulnerabilityCategory.INSECURE_CONFIGURATION:
          nistCategory = 'PR.IP (Information Protection Processes)';
          break;
        default:
          nistCategory = 'PR.DS (Data Security)';
      }
      
      if (!nistMap.has(nistCategory)) {
        nistMap.set(nistCategory, []);
      }
      nistMap.get(nistCategory)!.push(finding);
    });
    
    return nistMap;
  }

  private generateOWASPAssessment(owaspFindings: Map<string, VulnerabilityFinding[]>): string {
    if (owaspFindings.size === 0) {
      return 'No findings mapped to OWASP Top 10 categories.';
    }

    let assessment = '';
    owaspFindings.forEach((findings, category) => {
      assessment += `**${category}:** ${findings.length} findings\n`;
    });
    
    return assessment;
  }

  private generateNISTAssessment(nistFindings: Map<string, VulnerabilityFinding[]>): string {
    if (nistFindings.size === 0) {
      return 'No findings mapped to NIST Cybersecurity Framework categories.';
    }

    let assessment = '';
    nistFindings.forEach((findings, category) => {
      assessment += `**${category}:** ${findings.length} findings\n`;
    });
    
    return assessment;
  }

  private generateAWSWellArchitectedAssessment(findings: VulnerabilityFinding[]): string {
    const securityPillarFindings = findings.filter(f => 
      f.description.toLowerCase().includes('aws') ||
      f.location.filePath.includes('infrastructure')
    );

    return `**Security Pillar Assessment:** ${securityPillarFindings.length} findings related to AWS security best practices

Key areas for improvement:
- Identity and Access Management (IAM)
- Detective Controls (CloudWatch, CloudTrail)
- Infrastructure Protection (VPC, Security Groups)
- Data Protection (Encryption, Backup)`;
  }

  private generateDetailedFindings(findings: VulnerabilityFinding[]): string {
    if (findings.length === 0) {
      return 'No detailed findings to report.';
    }

    let details = '';
    findings.forEach((finding, index) => {
      details += `### Finding ${index + 1}: ${finding.title}\n\n`;
      details += `**Severity:** ${finding.severity}\n`;
      details += `**Category:** ${finding.category}\n`;
      details += `**File:** \`${finding.location.filePath}\`\n`;
      if (finding.location.lineNumber) {
        details += `**Line:** ${finding.location.lineNumber}\n`;
      }
      details += `**CWE ID:** ${finding.cweId || 'N/A'}\n\n`;
      details += `**Description:** ${finding.description}\n\n`;
      details += `**Impact:** ${finding.impact}\n\n`;
      details += `**Evidence:**\n\`\`\`\n${finding.evidence.join('\n')}\n\`\`\`\n\n`;
      details += `**Remediation:**\n${finding.remediation.summary}\n\n`;
      details += `**Timeline:** ${finding.remediation.timeline}\n\n`;
      details += '---\n\n';
    });

    return details;
  }
}